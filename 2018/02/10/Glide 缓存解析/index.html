<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="深入系列,Glide,图片请求框架解析,">










<meta name="description" content="Glide 缓存解析前言Glide 是 Android 开发中大名鼎鼎的图片加载框架，它通过三级缓存实现了对图片加载的优化，又通过内部的图片池实现了对移动端内存的优化 这篇文章的目的是深入解析 Glide 加载一张来自网络图片时的流程及各种控制优化，基于 Glide V4 分析 简单使用Glide 加载图片非常简单，一行代码足矣 123Glide.with(fragment)    .load(m">
<meta name="keywords" content="深入系列,Glide,图片请求框架解析">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide 缓存解析">
<meta property="og:url" content="http://sanousun.github.io/2018/02/10/Glide 缓存解析/index.html">
<meta property="og:site_name" content="sanousun">
<meta property="og:description" content="Glide 缓存解析前言Glide 是 Android 开发中大名鼎鼎的图片加载框架，它通过三级缓存实现了对图片加载的优化，又通过内部的图片池实现了对移动端内存的优化 这篇文章的目的是深入解析 Glide 加载一张来自网络图片时的流程及各种控制优化，基于 Glide V4 分析 简单使用Glide 加载图片非常简单，一行代码足矣 123Glide.with(fragment)    .load(m">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://sanousun.github.io/images/glide_resouce_loader.png">
<meta property="og:image" content="http://sanousun.github.io/images/glide_cache.png">
<meta property="og:updated_time" content="2019-02-28T08:13:31.402Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide 缓存解析">
<meta name="twitter:description" content="Glide 缓存解析前言Glide 是 Android 开发中大名鼎鼎的图片加载框架，它通过三级缓存实现了对图片加载的优化，又通过内部的图片池实现了对移动端内存的优化 这篇文章的目的是深入解析 Glide 加载一张来自网络图片时的流程及各种控制优化，基于 Glide V4 分析 简单使用Glide 加载图片非常简单，一行代码足矣 123Glide.with(fragment)    .load(m">
<meta name="twitter:image" content="http://sanousun.github.io/images/glide_resouce_loader.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sanousun.github.io/2018/02/10/Glide 缓存解析/">





  <title>Glide 缓存解析 | sanousun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sanousun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">sanousun的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sanousun.github.io/2018/02/10/Glide 缓存解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sanousun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanousun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Glide 缓存解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T22:47:44+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Glide-缓存解析"><a href="#Glide-缓存解析" class="headerlink" title="Glide 缓存解析"></a>Glide 缓存解析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Glide 是 Android 开发中大名鼎鼎的图片加载框架，它通过三级缓存实现了对图片加载的优化，又通过内部的图片池实现了对移动端内存的优化</p>
<p>这篇文章的目的是深入解析 Glide 加载一张来自网络图片时的流程及各种控制优化，基于 Glide V4 分析</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>Glide 加载图片非常简单，一行代码足矣</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">    .load(myUrl)</span><br><span class="line">    .into(imageView)</span><br></pre></td></tr></table></figure>
<p>那我们以改代码为例，深入了解其加载流程，以及这期间涉及到的缓存模型</p>
<p>先提一些概念性的东西</p>
<ul>
<li>Model：数据源，可能是 url，资源 id 等等</li>
<li>Data：源数据，来自于 model</li>
<li>Resource：我们所需资源的包装类，内部有对象池的缓存和重用，所持有的资源是我们真正想要的，比如说 bitmap</li>
<li>ModelLoader： 将 Model 转化成 Data，ModelLoader 有两个方法，一个 handles 表示是否可以处理这个类型的 Model，如果可以的话就可以通过 buildLoadData 生成一个LoadData，而 LoadData 包含了要用来做缓存的 key，及用来获取数据的 DataFetcher</li>
<li>Decoder： Data 转化成 Resource</li>
<li>ResourceTranscoder：对原始的 Resource 处理转化，比如说圆角啊，缩略啊</li>
<li>Encoder：持久化数据，将原始的 Resource 持久化缓存到磁盘里，还有一个子类 ResourceEncoder，这个则是用来持久化处理过的 Resource 的</li>
</ul>
<p>后面提到的工具都会在 Registry 里注册，这里展示一个最简单的数据第一次获取流程<br><img src="/images/glide_resouce_loader.png" alt="数据处理流程"></p>
<h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><h3 id="请求构建解析"><a href="#请求构建解析" class="headerlink" title="请求构建解析"></a>请求构建解析</h3><p><strong>Glide.with 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回了一个 RequestManager 对象，以供后续的代码调用，而 RequestManager 经过 getRetriever 方法层层追踪可以得知是由 Glide 单例对象中持有的 RequestManagerRetriever 中 RequestManagerFactory 工厂生成的，至于具体是如何生成的先略去不谈</p>
<p><strong>RequestManager.load 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过传入的 model 构建一个加载 Drawable 的 RequestBuilder，还是处于请求构建阶段，那么最关键的加载过程应该追踪到 RequestBuilder.into 方法中了</p>
<p><strong>RequestBuilder.into 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否在 Android 主线程调用，会涉及到 view 操作</span></span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="comment">// View 当然不能为空</span></span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    RequestOptions requestOptions = <span class="keyword">this</span>.requestOptions;</span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过克隆处理复用问题</span></span><br><span class="line">        <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_XY:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CENTER:</span><br><span class="line">            <span class="keyword">case</span> MATRIX:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">        requestOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了一些校验判断，以及对 ImageView 的特殊处理（根据 transcodeClass 创建对应的 ImageViewTarget，这里应该是 Drawable.class），最终调用了真正的 into 方法</p>
<p>执行加载流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">      RequestOptions options)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = options.autoClone();</span><br><span class="line">    <span class="comment">// 构建 request 对象，里面的构建过程比较复杂，这个 request 对象其实是多个 request 组合而成</span></span><br><span class="line">    Request request = buildRequest(target, targetListener, options);</span><br><span class="line">    <span class="comment">// request 执行时会通过 tag 的形式绑定在 View 上，所以这里可以找到目标 view 以前可能执行过的图片加载请求</span></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    <span class="comment">// 如果绑定的前请求等价于新请求，可以直接使用前请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)) &#123;</span><br><span class="line">        <span class="comment">// request 需要回收到对象池中等待复用</span></span><br><span class="line">        request.recycle();</span><br><span class="line">        <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">        <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">        <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">        <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">        <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">            <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">            <span class="comment">// setting placeholders, tracking and untracking Targets, and obtaining View dimensions that</span></span><br><span class="line">            <span class="comment">// are done in the individual Request.</span></span><br><span class="line">            previous.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先对 target 做一些必要的清理工作</span></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    <span class="comment">// 将 request 绑定到 target 上</span></span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    <span class="comment">// 将这两者绑定到管理器上，同时触发请求</span></span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追踪到 RequestManager.track 中发现最终会调用 Request.begin 方法，由于我们使用的是最简单的调用方式，所以 buildRequest 只是调用最简单的 SingleRequest.obtain 方法（这里采用了 Message 类似的对象池来防止频繁创建对象，因为在设置了缩略图和错误配置时会递归产生 requet 对象），直接追踪到 SingleRequest.begin 方法</p>
<p><strong>SingleRequest.begin 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertNotCallingCallbacks();</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">            width = overrideWidth;</span><br><span class="line">            height = overrideHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class="line">        <span class="comment">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class="line">        <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">        onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">"Received null model"</span>), logLevel);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot restart a running request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们在加载完成后重新启动加载流程（通常是在类似于 notifyDataSetChanged 的时候会启用一个完全一样的请求）</span></span><br><span class="line">    <span class="comment">// 我们可以使用上一次加载到的资源而不是一个新的请求</span></span><br><span class="line">    <span class="comment">// 如果需要加载更改后的配置，那么需要对原来目标先进行清除</span></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">        onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载必须发生在目标宽高明确之后</span></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回调</span></span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续处理，加载占位图</span></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为图片的加载是必须在宽高都明确了以后才执行，所以我们追踪到 SingleRequest.onSizeReady 方法</p>
<p><strong>SingleRequest.onSizeReady 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前置判断，并把状态置成 running</span></span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      logV(<span class="string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据缩略值计算宽高</span></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logV(<span class="string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里才是图片加载的流程，通过引擎加载，上述流程是对加载参数的处理</span></span><br><span class="line">    loadStatus = engine.load(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        requestOptions.getSignature(),</span><br><span class="line">        <span class="keyword">this</span>.width,</span><br><span class="line">        <span class="keyword">this</span>.height,</span><br><span class="line">        requestOptions.getResourceClass(),</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        requestOptions.getDiskCacheStrategy(),</span><br><span class="line">        requestOptions.getTransformations(),</span><br><span class="line">        requestOptions.isTransformationRequired(),</span><br><span class="line">        requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">        requestOptions.getOptions(),</span><br><span class="line">        requestOptions.isMemoryCacheable(),</span><br><span class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">        requestOptions.getUseAnimationPool(),</span><br><span class="line">        requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      logV(<span class="string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>图片的加载流程有 engine 负责，返回的 loadStatus 则是对这次引擎加载工作的描述，可以通过这个对象去取消此次加载。由于引擎的加载是基于异步的 io 操作，所以将 this 作为回调接口传入了。由于 Glide 的配置项非常多，所以其请求的构建流程也特别复杂，接下去就是真正的引擎加载流程</p>
<h3 id="引擎加载解析"><a href="#引擎加载解析" class="headerlink" title="引擎加载解析"></a>引擎加载解析</h3><p>先来聊聊 engine 的主要构成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引擎任务大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> JOB_POOL_SIZE = <span class="number">150</span>;</span><br><span class="line"><span class="comment">// 引擎任务池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, EngineJob&lt;?&gt;&gt; jobs;</span><br><span class="line"><span class="comment">// 缓存键构造工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EngineKeyFactory keyFactory;</span><br><span class="line"><span class="comment">// 内存缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</span><br><span class="line"><span class="comment">// 引擎任务工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EngineJobFactory engineJobFactory;</span><br><span class="line"><span class="comment">// 活动资源引用池，为防止内存泄漏通过弱引用持有</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class="line"><span class="comment">// 资源回收器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourceRecycler resourceRecycler;</span><br><span class="line"><span class="comment">// 本地缓存生产者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LazyDiskCacheProvider diskCacheProvider;</span><br><span class="line"><span class="comment">// 解码任务工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DecodeJobFactory decodeJobFactory;</span><br><span class="line"><span class="comment">// 资源引用队列</span></span><br><span class="line"><span class="keyword">private</span> ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue;</span><br></pre></td></tr></table></figure>
<p>具体这些是如何工作的，那就要结合加载过程来讲了</p>
<p><strong>Engine.load 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="comment">// 通过 EngineKeyFactory 生成缓存键</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">    <span class="comment">// 从内存中获取缓存资源</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从活动资源中获取缓存资源</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从任务池中获取任务</span></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">      current.addCallback(cb);</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建任务</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool, useAnimationPool);</span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        key,</span><br><span class="line">        signature,</span><br><span class="line">        width,</span><br><span class="line">        height,</span><br><span class="line">        resourceClass,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        diskCacheStrategy,</span><br><span class="line">        transformations,</span><br><span class="line">        isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform,</span><br><span class="line">        onlyRetrieveFromCache,</span><br><span class="line">        options,</span><br><span class="line">        engineJob);</span><br><span class="line">    <span class="comment">// 将新建的任务缓存起来</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从这个流程中我们来详细解析一下 Glide 的缓存策略</p>
<h3 id="缓存键-Cache-Keys"><a href="#缓存键-Cache-Keys" class="headerlink" title="缓存键 Cache Keys"></a>缓存键 Cache Keys</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br></pre></td></tr></table></figure>
<p>缓存键通过该方法生成，包含至少两个元素</p>
<ol>
<li>请求加载的 model（File, Url, Uri）</li>
<li>一个可选的签名（Signature）</li>
</ol>
<p>另外（活动资源，内存缓存，资源磁盘缓存）的缓存键还包含一些其他数据，包括：</p>
<ol>
<li>宽度和高度</li>
<li>可选的变换（Transformation）</li>
<li>额外添加的任何选项（Options）</li>
<li>请求的数据类型（Bitmap, GIF, 或其他）</li>
</ol>
<p>活动资源和内存缓存使用的键还和磁盘资源缓存略有不同，内存缓存通常有适应内存选项（Options），比如影响 Bitmap 配置的选项或其他解码时才会用到的参数</p>
<p>为了生成磁盘缓存上的缓存键名称，以上的每个元素会被哈希化以创建一个单独的字符串键名，并在随后作为磁盘缓存上的文件名使用。后面会根据具体的使用场景说明</p>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p><strong>Engine.loadFromCache 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="comment">// 如果并没有设置内存缓存，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 key 获取缓存</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 标记被使用次数，并加入到活动资源引用中</span></span><br><span class="line">        cached.acquire();</span><br><span class="line">        activeResources.put(key, <span class="keyword">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Engine.getEngineResourceFromCache 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// 从内存缓存中取，取出后移除，因为要添加到活动资源中去</span></span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">        <span class="comment">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class="line">        result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> EngineResource&lt;&gt;(cached, <span class="keyword">true</span> <span class="comment">/*isMemoryCacheable*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cache 对象就是 MemoryCache 内存缓存实例，默认的实现是一个 LruCache – 最近最少使用算法，当缓存空间满了的时候，将最近最少使用的数据从缓存空间中删除以增加可用的缓存空间来缓存新内容。</p>
<p>MemoryCache 中有关于资源移除的监听回调，有 engine 实现相关接口，最终回调的是 ResourceRecycler.recycle(resource)，最终调用的都是 Resource 自己实现的 recycle 方法释放对象已方便重用，拿最常用的 BitmapResource 来说吧，他就有一个 bitmapPool 用来存放已经释放的 bitmap 资源，新建的时候可以尝试着去 bitmapPool 去取（这里涉及到 inBitmap 相关知识，自行查阅），可以大大缓解内存抖动</p>
<h3 id="活动资源缓存"><a href="#活动资源缓存" class="headerlink" title="活动资源缓存"></a>活动资源缓存</h3><p><strong>Engine.loadFromActiveResources 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="keyword">boolean</span> isMemoryCacheable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; active = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从活动资源中获取</span></span><br><span class="line">    WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class="line">    <span class="comment">// 因为是软引用，所以判空必不可少</span></span><br><span class="line">    <span class="keyword">if</span> (activeRef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        active = activeRef.get();</span><br><span class="line">        <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 资源引用计数加一，用于资源释放的判断</span></span><br><span class="line">            active.acquire();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 被回收了则移除</span></span><br><span class="line">            activeResources.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>活动资源的引用比较简单，是一个参数为弱引用的池子，不用像内存缓存一样考虑缓存大小</p>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>根据 key 获取加载任务，如果已存在只需要把加载回调加入其中即可，因为相同的 key 代表着相同尅性的加载。如果不存在，再通过工厂新生成一个 EngineJob 和 DecodeJob，将 EngineJob 存入引用池后开始任务</p>
<p>这里要注意的是 glide 会对处理过的图片也进行缓存，默认状态是会先读取处理过的缓存数据，再读取原始缓存数据，最后才会尝试在数据源加载</p>
<p><strong>EngineJob.start(DecodeJob) 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">        ? diskCacheExecutor</span><br><span class="line">        : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会根据 DecodeJob 中持有的 DiskCacheStrategy 硬盘缓存策略来决定是否从硬盘缓存中读取还是从数据源读取（选取执行的线程池），无论选取哪个线程池，最终执行的都是 DecodeJob 的 run 方法</p>
<p><strong>DecodeJob.run</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供一些信息，防止线程池执行异常不报错</span></span><br><span class="line">    TraceCompat.beginSection(<span class="string">"DecodeJob#run"</span>);</span><br><span class="line">    <span class="comment">// try catch 保证出错是 localFetcher 会被清理</span></span><br><span class="line">    DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">            notifyFailed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行获取数据的操作</span></span><br><span class="line">        runWrapped();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常捕获，资源释放</span></span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"DecodeJob threw unexpectedly"</span></span><br><span class="line">                + <span class="string">", isCancelled: "</span> + isCancelled</span><br><span class="line">                + <span class="string">", stage: "</span> + stage, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stage != Stage.ENCODE) &#123;</span><br><span class="line">            throwables.add(t);</span><br><span class="line">            notifyFailed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清理 localFetcher</span></span><br><span class="line">        <span class="keyword">if</span> (localFetcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            localFetcher.cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        TraceCompat.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run 方法交由 runWrapped 执行</p>
<p><strong>DecodeJob.runWrapped 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">        <span class="comment">// 这是初始化状态</span></span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            <span class="comment">// 根据硬盘缓存策略选择缓存模式</span></span><br><span class="line">            stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">            <span class="comment">// 根据缓存模式选择 DataFetcher 生成器</span></span><br><span class="line">            currentGenerator = getNextGenerator();</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据当前状态和磁盘缓存策略获取下一个状态，那就能实现如果当前的 DataFetcher 抓取不到数据，</span></span><br><span class="line"><span class="comment"> * 就可以从下一级抓取数据，默认顺序是处理过的缓存数据-&gt;原始缓存数据-&gt;数据源数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">                ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">                ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">            <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据状态寻找 DataFetcherGenerator，用于数据的抓取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的模式是从 INITIALIZE 状态开始的，那么就会<br><strong>DecodeJob.runGenerators 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 查找合适的数据来源</span></span><br><span class="line">    <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">        stage = getNextStage(stage);</span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据来源是 SOURCE 的话，重新执行这个任务，为的是切换执行的线程池</span></span><br><span class="line">        <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">            reschedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果达到完成阶段了还没找到对应来源，就是加载失败了</span></span><br><span class="line">    <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">        notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则的话是会在生成器中启动一个相应的load，并在回调 onDataFetcherReady 中接收到我们想要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个过程可以概括为 </p>
<ol>
<li>取当前状态 stage</li>
<li>获取当前 stage 下的 DataFetcherGenerator</li>
<li>执行 DataFetcherGenerator.startNext，如果返回 true 即找到了缓存数据，结束循环，等待 onDataFetcherReady 回调，否则取下一个状态 stage 循环上述过程</li>
<li>Stage.FINISHED 状态且未找到缓存，加载失败</li>
</ol>
<p>stage 主要包括处理过的缓存，原始数据缓存以及数据源</p>
<p>DataFetcherGenerator.startNext 内的主要逻辑就是生成一个缓存键，通过这个键去查找磁盘中可以缓存的 File，如果存在则再去查找对应的 ModelLoader，最后通过 ModelLoader 中持有的 DataFetcher 去加载数据，以 SourceGenerator 为例，因为它里面还包括了缓存的相关流程</p>
<p><strong>SourceGenerator.startNext 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法会多次被调用</span></span><br><span class="line">    <span class="comment">// 缓存数据相关操作，第一次调用为 null，所以不会执行，先放一边</span></span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object data = dataToCache;</span><br><span class="line">      dataToCache = <span class="keyword">null</span>;</span><br><span class="line">      cacheData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用 null，也不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    loadData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">        <span class="comment">// 这里是遍历所有注册的 ModelLoader，将创建的 LoadData 放到集合里，找到符合的 LoadData，通过 fetcher 加载数据</span></span><br><span class="line">        loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">        <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fetcher 加载完成会回调通知 onDataReady 方法</p>
<p><strong>SourceGenerator.onDataReady 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">        <span class="comment">// 如果开启缓存，则会执行 DecodeJob.reschedule</span></span><br><span class="line">        dataToCache = data;</span><br><span class="line">        <span class="comment">// We might be being called back on someone else's thread. Before doing anything, we should</span></span><br><span class="line">        <span class="comment">// reschedule to get back onto Glide's thread.</span></span><br><span class="line">        cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DecodeJob.reschedule 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</span><br><span class="line">    <span class="comment">// 这边触发 callback.reschedule 会使 DecodeJob 在 ActiveSourceExecutor 上再重新跑一遍</span></span><br><span class="line">    callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 DecodeJob.runWrapper 方法，由于 runReason = RunReason.SWITCH_TO_SOURCE_SERVICE 所以直接执行了 runGenerators 方法，其实第一次执行 SourceGenerator.startNext 时就已经先执行了这个流程，作为数据源请求，需要在别的线程池上跑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    cacheData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个过程会被执行</p>
<p><strong>SourceGenerator.cacheData 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheData</span><span class="params">(Object dataToCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Encoder 写入缓存到磁盘</span></span><br><span class="line">        Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">        DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">            <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">        originalKey = <span class="keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br><span class="line">        <span class="comment">// 存入到磁盘缓存中去，默认是 DiskLruCache 实现</span></span><br><span class="line">        helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Finished encoding source to cache"</span></span><br><span class="line">                + <span class="string">", key: "</span> + originalKey</span><br><span class="line">                + <span class="string">", data: "</span> + dataToCache</span><br><span class="line">                + <span class="string">", encoder: "</span> + encoder</span><br><span class="line">                + <span class="string">", duration: "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        loadData.fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 sourceCacheGenerator 赋值，可以在 startNext 中继续执行</span></span><br><span class="line">    sourceCacheGenerator =</span><br><span class="line">        <span class="keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 startNext 中，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待到 sourceCacheGenerator 中对应的 fetcher 执行完毕就会回调 SourceCacheGenerator.onDataReady 方法，再回调 SourceGenerator.onDataFetcherReady 方法，最终回调<br>DecodeJob.onDataFetcherReady 方法</p>
<p><strong>DecodeJob.onDataFetcherReady 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">    <span class="keyword">this</span>.currentData = data;</span><br><span class="line">    <span class="keyword">this</span>.currentFetcher = fetcher;</span><br><span class="line">    <span class="keyword">this</span>.currentDataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">    <span class="comment">// 切换到目标线程执行</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">        runReason = RunReason.DECODE_DATA;</span><br><span class="line">        callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TraceCompat.beginSection(<span class="string">"DecodeJob.decodeFromRet   rievedData"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            TraceCompat.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DecodeJob.decodeFromRetrievedData 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Retrieved data"</span>, startFetchTime,</span><br><span class="line">            <span class="string">"data: "</span> + currentData</span><br><span class="line">            + <span class="string">", cache key: "</span> + currentSourceKey</span><br><span class="line">            + <span class="string">", fetcher: "</span> + currentFetcher);</span><br><span class="line">    &#125;</span><br><span class="line">    Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里完成了对图片的处理</span></span><br><span class="line">        resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">        e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">        throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存处理后的资源</span></span><br><span class="line">        notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DecodeJob.notifyEncodeAndRelease 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Initializable) &#123;</span><br><span class="line">        ((Initializable) resource).initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource&lt;R&gt; result = resource;</span><br><span class="line">    LockedResource&lt;R&gt; lockedResource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从对象池里去对象赋值</span></span><br><span class="line">    <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">        lockedResource = LockedResource.obtain(resource);</span><br><span class="line">        result = lockedResource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 资源加载完成回调</span></span><br><span class="line">    notifyComplete(result, dataSource);</span><br><span class="line"></span><br><span class="line">    stage = Stage.ENCODE;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 做处理后的资源缓存</span></span><br><span class="line">        <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">            deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockedResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lockedResource.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载过程完成，释放 DecodeJob 对象，加入到复用池中</span></span><br><span class="line">        onEncodeComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，最简单的一个加载流程已经完成，可以用一张图来表示<br><img src="/images/glide_cache.png" alt="加载来源获取流程图"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文从一个最简单的图片加载操作完整追踪整个缓存路径，虽然还有许多细节没有涉及到，但确实也是因为 glide 是个非常庞大的图片加载库，为了内存优化、性能改善做了非常多的努力，比如说对列表图片加载的优化等等，希望可以开个好头，激起你探索的兴趣吧</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/深入系列/" rel="tag"># 深入系列</a>
          
            <a href="/tags/Glide/" rel="tag"># Glide</a>
          
            <a href="/tags/图片请求框架解析/" rel="tag"># 图片请求框架解析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/23/okhttp 网络请求解析/" rel="next" title="okhttp 网络请求解析">
                <i class="fa fa-chevron-left"></i> okhttp 网络请求解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/12/Android 触摸事件分发解析/" rel="prev" title="Android 触摸事件分发解析">
                Android 触摸事件分发解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sanousun</p>
              <p class="site-description motion-element" itemprop="description">随便写写，随缘</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Glide-缓存解析"><span class="nav-number">1.</span> <span class="nav-text">Glide 缓存解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单使用"><span class="nav-number">1.2.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程解析"><span class="nav-number">1.3.</span> <span class="nav-text">流程解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求构建解析"><span class="nav-number">1.3.1.</span> <span class="nav-text">请求构建解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引擎加载解析"><span class="nav-number">1.3.2.</span> <span class="nav-text">引擎加载解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存键-Cache-Keys"><span class="nav-number">1.3.3.</span> <span class="nav-text">缓存键 Cache Keys</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存缓存"><span class="nav-number">1.4.</span> <span class="nav-text">内存缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#活动资源缓存"><span class="nav-number">1.4.1.</span> <span class="nav-text">活动资源缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘缓存"><span class="nav-number">1.4.2.</span> <span class="nav-text">磁盘缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">1.5.</span> <span class="nav-text">结语</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sanousun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
