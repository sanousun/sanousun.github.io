<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="内存优化,集合框架,">










<meta name="description" content="内存优化 —— ArrayMap,SparseArray前言HashMap 是 Java 中常用的 map 容器，凭借着可靠的链表数组结构，在增删改查方面的性能十分优异，但是 HashMap 确有着致命的缺点——内存占用很大，因为 HashMap 中数组占用的内存是提前申请好的，在某些条件下，hash 分布并不是平均的，甚至都是同一个位置，数组其他位置内存虽然被分配了，但是并没有被使用。而且数据不">
<meta name="keywords" content="内存优化,集合框架">
<meta property="og:type" content="article">
<meta property="og:title" content="内存优化 —— ArrayMap,SparseArray">
<meta property="og:url" content="http://sanousun.github.io/2017/12/20/内存优化 —— ArrayMap,SparseArray/index.html">
<meta property="og:site_name" content="sanousun">
<meta property="og:description" content="内存优化 —— ArrayMap,SparseArray前言HashMap 是 Java 中常用的 map 容器，凭借着可靠的链表数组结构，在增删改查方面的性能十分优异，但是 HashMap 确有着致命的缺点——内存占用很大，因为 HashMap 中数组占用的内存是提前申请好的，在某些条件下，hash 分布并不是平均的，甚至都是同一个位置，数组其他位置内存虽然被分配了，但是并没有被使用。而且数据不">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://sanousun.github.io/images/android_perf_3_arraymap_two_array.jpg">
<meta property="og:image" content="http://sanousun.github.io/images/android_perf_3_arraymap_binary_search.jpg">
<meta property="og:updated_time" content="2019-02-28T08:16:42.343Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="内存优化 —— ArrayMap,SparseArray">
<meta name="twitter:description" content="内存优化 —— ArrayMap,SparseArray前言HashMap 是 Java 中常用的 map 容器，凭借着可靠的链表数组结构，在增删改查方面的性能十分优异，但是 HashMap 确有着致命的缺点——内存占用很大，因为 HashMap 中数组占用的内存是提前申请好的，在某些条件下，hash 分布并不是平均的，甚至都是同一个位置，数组其他位置内存虽然被分配了，但是并没有被使用。而且数据不">
<meta name="twitter:image" content="http://sanousun.github.io/images/android_perf_3_arraymap_two_array.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sanousun.github.io/2017/12/20/内存优化 —— ArrayMap,SparseArray/">





  <title>内存优化 —— ArrayMap,SparseArray | sanousun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sanousun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">sanousun的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sanousun.github.io/2017/12/20/内存优化 —— ArrayMap,SparseArray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sanousun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sanousun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">内存优化 —— ArrayMap,SparseArray</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T18:26:07+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="内存优化-——-ArrayMap-SparseArray"><a href="#内存优化-——-ArrayMap-SparseArray" class="headerlink" title="内存优化 —— ArrayMap,SparseArray"></a>内存优化 —— ArrayMap,SparseArray</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap 是 Java 中常用的 map 容器，凭借着可靠的链表数组结构，在增删改查方面的性能十分优异，但是 HashMap 确有着致命的缺点——内存占用很大，因为 HashMap 中数组占用的内存是提前申请好的，在某些条件下，hash 分布并不是平均的，甚至都是同一个位置，数组其他位置内存虽然被分配了，但是并没有被使用。而且数据不断增多还会触发数组的扩容，还会加剧这种状况（这是由 hashmap 的扩容算法决定的）</p>
<p>所以 Android 为解决这种状态，提供了内存效率更高的 ArrayMap 和 SparseArray，值得注意的是 ArrayMap 直到 API 19 才加入到 Android 中但是在 Support 包中有提供</p>
<p>本文基于 Android API 27，为了直观表现截取了部分 Android 性能优化典范视频的一些截图</p>
<h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>以 android.support.v4.util.ArrayMap 为例，下面是类注释中摘抄的一段关于 ArrayMap 原理的描述</p>
<blockquote>
<p>It keeps its mappings in an array data structure – an integer array of hash codes for each item, and an Object array of the key/value pairs. This allows it to avoid having to create an extra object for every entry put in to the map, and it also tries to control the growth of the size of these arrays more aggressively (since growing them only requires copying the entries in the array, not rebuilding a hash map).</p>
</blockquote>
<p>ArrayMap 通过两个数组实现映射关系，一个 int 数组用来存放 hash 值，而另外一个 object 数组存放 key/value 的组合。这种方式即可以避免为放入 map 的 kv 生成一个额外的对象（HashMap.Node，维护 hash 碰撞时的链表结构），也可以避免 hashmap 扩容时需要重建 map 的开销（只需要数组的复制）。忽略 Java Container API 的需求，真正的逻辑实现在 SimpleArrayMap 类中。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>ArrayMap 有两个主要组成结构，一个是存放 hash 值的 int 型数组 mHashs，还有一个就是 key value 依次对应存放的 object 型数组 mArray。数组中的元素紧密排列，可以极大的利用内存。</p>
<p><img src="/images/android_perf_3_arraymap_two_array.jpg" alt="android_perf_3_arraymap_two_array"></p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p><strong>ArrayMap.get 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? (V)mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get 方法先从 mHashs 数组中查找到对应的 index，然后映射得到 mArray 中的 <code>index * 2 + 1</code> 中的 value 值，继续追踪 indexOfKey 方法</p>
<p><strong>ArrayMap.indexOfKey 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOfKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? indexOfNull()</span><br><span class="line">            : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据策略选取 hashCode 的计算方法，System.identityHashCode 方法是通过对象的内存地址得到的 hashCode，继续追踪 indexOf 方法</p>
<p><strong>ArrayMap.indexOf 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组为空时，直接返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 按位取反就是 -1</span></span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过二分查找去 mHashs 数组中查找目标 hash，说明 mHashs 是有序的 </span></span><br><span class="line">    <span class="keyword">int</span> index = binarySearchHashes(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有查找到，index 其实并不为 0，而是 hash 本来应该在的位置，但是为了区分 hash 在目标数组内的情况，所以对 index 做了取反操作，所以是小于 0 的</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果查找到了 index，通过 equals 方法与 mArray 中 index * 2 位置上存放的 key 值比较，</span></span><br><span class="line">    <span class="comment">// 相同则是我们要找的目标，value 在 mArray 中 index * 2 + 1 位置</span></span><br><span class="line">    <span class="keyword">if</span> (key.equals(mArray[index&lt;&lt;<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生 hash 碰撞时的处理逻辑，前后查找是否有符合的 key 值</span></span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (end = index + <span class="number">1</span>; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[end &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; mHashes[i] == hash; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[i &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到，而这里的 index 则是靠后的位置，这样做是为了添加元素时数组拷贝尽可能的少</span></span><br><span class="line">    <span class="keyword">return</span> ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找的逻辑比较简单，mHashs 数组是个有序数组，所以查找时可以使用二分查找（时间复杂度 <code>O(log2n)</code>），查找到 hash 的index 后可以去 mArray 中找到 key 比较来确定是否是我们要查找的 key，因为是两倍关系，可以通过位操作来提高性能。</p>
<p><img src="/images/android_perf_3_arraymap_binary_search.jpg" alt="android_perf_3_arraymap_binary_search"></p>
<p>既然 mHash 是有序的，那么插入删除操作必须有排序的过程</p>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p><strong>ArrayMap.put</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> osize = mSize;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">// key 为空时处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// key 为空，hash 即为 0，这里需要单独处理</span></span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();</span><br><span class="line">        index = indexOf(key, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已存在 key 则只需要替换掉对应的 value 即可</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> V old = (V)mArray[index];</span><br><span class="line">        mArray[index] = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然 hash 不在数组中，但是 index 就是该 hash 值应该在 mHashs 中的位置，只不过取了反，所以这里需要再取反，得到的 index 就是需要插入的位置</span></span><br><span class="line">    index = ~index;</span><br><span class="line">    <span class="comment">// 数组的扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (osize &gt;= mHashes.length) &#123;</span><br><span class="line">        <span class="comment">// 扩容逻辑是小于 4，扩容到 4</span></span><br><span class="line">        <span class="comment">// 大于 4 小于 8，扩容到 8</span></span><br><span class="line">        <span class="comment">// 大于 8 扩容 1.5 倍</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = osize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (osize+(osize&gt;&gt;<span class="number">1</span>))</span><br><span class="line">                : (osize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: grow from "</span> + mHashes.length + <span class="string">" to "</span> + n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">        <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">        <span class="comment">// 生成数组，对 4，8 容量有缓存处理</span></span><br><span class="line">        allocArrays(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: copy 0-"</span> + osize + <span class="string">" to 0"</span>);</span><br><span class="line">            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原有的数组中的 4，8 容量数组会被缓存，这样可以防止低容量数组操作时的内存抖动</span></span><br><span class="line">        freeArrays(ohashes, oarray, osize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index 对 hash 碰撞情况下的插入位置也做了优化</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; osize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: move "</span> + index + <span class="string">"-"</span> + (osize-index)</span><br><span class="line">                + <span class="string">" to "</span> + (index+<span class="number">1</span>));</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, osize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CONCURRENT_MODIFICATION_EXCEPTIONS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (osize != mSize || index &gt;= mHashes.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">    mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br><span class="line">    <span class="comment">// 数据大小增加</span></span><br><span class="line">    mSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然逻辑简单，但是设计地十分严谨，为了保证数据小容量下的频繁插入操作，有选择性的做了缓存数组。为了尽量少的拷贝数组，对 index 插入位置也做了优化，选取了数组靠后的位置。 remove 方法也类似，只是在数据大小大于 8，小于三分之一数组大小时会缩减数据，移除数据时也会做数据拷贝。ArrayMap 不支持并发操作</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>鉴于数组的结构，对于 ArrayMap 的遍历是十分高效的，我们可以直接使用数组下标访问对应内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.size(); i++)&#123;</span><br><span class="line">    Object key = map.keyAt(i);</span><br><span class="line">    Object value = map.valueAt(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，空的 ArrayMap 并不会占用内存。虽然 ArrayMap 对于节省内存方面做了许多优化，但是这种数据拷贝的方式在大数据场景下其实是非常浪费性能的。所以 ArrayMap 适用于数据量千以下的使用场景</p>
<h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><p>HaspMap 的另一个缺点就是存放的 key/value 都必须是对象，对于以基本数据类型（boolean, int, long等）需要存入的是其包装类（Boolean, Integer, Long等），对于 HaspMap 的增删改查很容易产生大量自动拆装箱操作，这是很影响性能的。因此 Android 提供了一下容器来替代这种基本数据类型下的 map 操作。</p>
<table>
<thead>
<tr>
<th>class</th>
<th>\&lt;key, value&gt; </th>
</tr>
</thead>
<tbody>
<tr>
<td>SparseArray</td>
<td>\&lt;int, obj&gt; </td>
</tr>
<tr>
<td>SparseBooleanArray</td>
<td>\&lt;int, boolean&gt; </td>
</tr>
<tr>
<td>SparseLongArray</td>
<td>\&lt;int, long&gt; </td>
</tr>
<tr>
<td>LongSparseArray</td>
<td>\&lt;long, obj&gt; </td>
</tr>
</tbody>
</table>
<p>下面以 SparseArray 为例，对其中的优化进行追踪说明</p>
<h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><p>与 ArrayMap 相似，有个两个数组，一个是存放 key 的 int 型数组，另一个是存放 value 的 object 数组，相对于 ArrayMap 来说简化了不少，因为 key 本身就可以看做是 hash 了。</p>
<h3 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h3><p><strong>SparseArray.get 方法</strong></p>
<p>get 方法调用了 get(key, valueIfKeyNotFound) 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || mValues[i] == DELETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> valueIfKeyNotFound;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 ArrayMap 一样，key 数组也是有序的，通过二分查找寻找目标 key，只是这里少了 hash 产生碰撞时的逻辑。而且这里有一个 mValues[i] == DELETED 的判断，说明删除时的逻辑和 ArrayMap 不同，是以一个 DELETED 去替代，省去了数据拷贝相关操作。先查看 remove 操作再追踪 put 方法查看扩容相关逻辑。</p>
<h3 id="remove-amp-put"><a href="#remove-amp-put" class="headerlink" title="remove &amp; put"></a>remove &amp; put</h3><p>remove 其实调用的是 delete</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete 在只是在将要移除的 value 指向一个 DELETED 引用，并将 mGarbage 标志位置为 true，意味着数组中有被移除的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找目标位置</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未找到，取反获取插入位置</span></span><br><span class="line">        i = ~i;</span><br><span class="line">        <span class="comment">// 如果不需要扩容，而且对应位置有值且是被移除的了，重新赋值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            <span class="comment">// mGarbage 标志着有移除操作，需要 gc 操作去调整数组</span></span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 位置改变需要重新计算插入位置</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供的插入方法，逻辑比较简单</span></span><br><span class="line">        <span class="comment">// 拷贝插入位置后的数据往后一格</span></span><br><span class="line">        <span class="comment">// 扩容逻辑：小于 4，扩容到8，否则两倍扩容</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SparseArray.gc 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑比较简单，就是如果对应位置已经被删除了，那么就把后面的数据往前拷贝，最后剩下的置为 null，操作后保证前 o 个数据是有效的，剔除了被移除数据</p>
<p>可以看出 SparseArray 的删除操作是非常有效率的，但是缺少了减小数组的相当操作</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Android 为</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/内存优化/" rel="tag"># 内存优化</a>
          
            <a href="/tags/集合框架/" rel="tag"># 集合框架</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/28/Kotlin 入门/" rel="next" title="Kotlin 入门">
                <i class="fa fa-chevron-left"></i> Kotlin 入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/08/RxJava2.x 订阅流程解析/" rel="prev" title="RxJava2.x 订阅流程解析">
                RxJava2.x 订阅流程解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sanousun</p>
              <p class="site-description motion-element" itemprop="description">随便写写，随缘</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#内存优化-——-ArrayMap-SparseArray"><span class="nav-number">1.</span> <span class="nav-text">内存优化 —— ArrayMap,SparseArray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayMap"><span class="nav-number">1.2.</span> <span class="nav-text">ArrayMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本结构"><span class="nav-number">1.2.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-方法"><span class="nav-number">1.2.2.</span> <span class="nav-text">get 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-方法"><span class="nav-number">1.2.3.</span> <span class="nav-text">put 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">1.2.4.</span> <span class="nav-text">遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SparseArray"><span class="nav-number">1.3.</span> <span class="nav-text">SparseArray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本结构-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-方法-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">get 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-amp-put"><span class="nav-number">1.3.3.</span> <span class="nav-text">remove &amp; put</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">1.4.</span> <span class="nav-text">结语</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sanousun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
